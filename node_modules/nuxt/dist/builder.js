/*!
 * Nuxt.js v1.0.0-alpha.4
 * Released under the MIT License.
 */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _ = require('lodash');
var ___default = _interopDefault(_);
var chokidar = _interopDefault(require('chokidar'));
var fs = require('fs-extra');
var fs__default = _interopDefault(fs);
var hash = _interopDefault(require('hash-sum'));
var pify = _interopDefault(require('pify'));
var webpack = _interopDefault(require('webpack'));
var serialize = _interopDefault(require('serialize-javascript'));
var path = require('path');
var Tapable = _interopDefault(require('tappable'));
var MFS = _interopDefault(require('memory-fs'));
var webpackDevMiddleware = _interopDefault(require('webpack-dev-middleware'));
var webpackHotMiddleware = _interopDefault(require('webpack-hot-middleware'));
var Debug = _interopDefault(require('debug'));
var Glob = _interopDefault(require('glob'));
require('chalk');
var HTMLPlugin = _interopDefault(require('html-webpack-plugin'));
var FriendlyErrorsWebpackPlugin = _interopDefault(require('friendly-errors-webpack-plugin'));
var ProgressBarPlugin = _interopDefault(require('progress-bar-webpack-plugin'));
var webpackBundleAnalyzer = require('webpack-bundle-analyzer');
var ExtractTextPlugin = _interopDefault(require('extract-text-webpack-plugin'));
var autoprefixer = _interopDefault(require('autoprefixer'));
var nodeExternals = _interopDefault(require('webpack-node-externals'));
var fs$1 = _interopDefault(require('fs'));
var htmlMinifier = require('html-minifier');

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = 'object' === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve$$1, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve$$1, reject);
          }, function(err) {
            invoke("throw", err, resolve$$1, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve$$1(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve$$1, reject) {
          invoke(method, arg, resolve$$1, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof commonjsGlobal === "object" ? commonjsGlobal :
  typeof window === "object" ? window :
  typeof self === "object" ? self : commonjsGlobal
);
});

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof commonjsGlobal === "object" ? commonjsGlobal :
  typeof window === "object" ? window :
  typeof self === "object" ? self : commonjsGlobal;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

var runtimeModule = runtime;

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

var index$1 = runtimeModule;

var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve$$1, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve$$1(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var waitFor = function () {
  var _ref = asyncToGenerator(index$1.mark(function _callee(ms) {
    return index$1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt('return', new Promise(function (resolve$$1) {
              setTimeout(resolve$$1, ms || 0);
            }));

          case 1:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function waitFor(_x) {
    return _ref.apply(this, arguments);
  };
}();

function urlJoin() {
  return [].slice.call(arguments).join('/').replace(/\/+/g, '/').replace(':/', '://');
}

function isUrl(url) {
  return url.indexOf('http') === 0 || url.indexOf('//') === 0;
}

function promisifyRoute(fn) {
  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn);
  }
  // If routes is a function expecting a callback
  if (fn.length === 1) {
    return new Promise(function (resolve$$1, reject) {
      fn(function (err, routeParams) {
        if (err) {
          reject(err);
        }
        resolve$$1(routeParams);
      });
    });
  }
  var promise = fn();
  if (!promise || !(promise instanceof Promise) && typeof promise.then !== 'function') {
    promise = Promise.resolve(promise);
  }
  return promise;
}



function parallel(tasks, fn) {
  return Promise.all(tasks.map(function (task) {
    return fn(task);
  }));
}



function wp(p) {
  /* istanbul ignore if */
  if (/^win/.test(process.platform)) {
    p = p.replace(/\\/g, '\\\\');
  }
  return p;
}

var reqSep = /\//g;
var sysSep = ___default.escapeRegExp(path.sep);
var normalize = function normalize(string) {
  return string.replace(reqSep, sysSep);
};

function r() {
  var args = Array.prototype.slice.apply(arguments);
  var lastArg = ___default.last(args);

  if (lastArg.indexOf('@') !== -1 || lastArg.indexOf('~') !== -1) {
    return wp(lastArg);
  }

  return wp(path.resolve.apply(undefined, toConsumableArray(args.map(normalize))));
}

function relativeTo() {
  var args = Array.prototype.slice.apply(arguments);
  var dir = args.shift();

  // Resolve path
  var path$$1 = r.apply(undefined, toConsumableArray(args));

  // Check if path is an alias
  if (path$$1.indexOf('@') !== -1 || path$$1.indexOf('~') !== -1) {
    return path$$1;
  }

  // Make correct relative path
  var rp = path.relative(dir, path$$1);
  if (rp[0] !== '.') {
    rp = './' + rp;
  }
  return wp(rp);
}

function flatRoutes(router) {
  var path$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var routes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  router.forEach(function (r) {
    if (!(r.path.indexOf(':') !== -1) && !(r.path.indexOf('*') !== -1)) {
      /* istanbul ignore if */
      if (r.children) {
        flatRoutes(r.children, path$$1 + r.path + '/', routes);
      } else {
        routes.push((r.path === '' && path$$1[path$$1.length - 1] === '/' ? path$$1.slice(0, -1) : path$$1) + r.path);
      }
    }
  });
  return routes;
}

function cleanChildrenRoutes(routes) {
  var isChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var start = -1;
  var routesIndex = [];
  routes.forEach(function (route) {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      var res = route.name.split('-');
      var s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach(function (route) {
    route.path = isChild ? route.path.replace('/', '') : route.path;
    if (route.path.indexOf('?') > -1) {
      var names = route.name.split('-');
      var paths = route.path.split('/');
      if (!isChild) {
        paths.shift();
      } // clean first / for parents
      routesIndex.forEach(function (r) {
        var i = r.indexOf('index') - start; //  children names
        if (i < paths.length) {
          for (var a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }
            if (a < i && names[a] !== r[a]) {
              break;
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }
    route.name = route.name.replace(/-index$/, '');
    if (route.children) {
      if (route.children.find(function (child) {
        return child.path === '';
      })) {
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes;
}

function createRoutes(files, srcDir) {
  var routes = [];
  files.forEach(function (file) {
    var keys = file.replace(/^pages/, '').replace(/\.vue$/, '').replace(/\/{2,}/g, '/').split('/').slice(1);
    var route = { name: '', path: '', component: r(srcDir, file) };
    var parent = routes;
    keys.forEach(function (key, i) {
      route.name = route.name ? route.name + '-' + key.replace('_', '') : key.replace('_', '');
      route.name += key === '_' ? 'all' : '';
      var child = ___default.find(parent, { name: route.name });
      if (child) {
        if (!child.children) {
          child.children = [];
        }
        parent = child.children;
        route.path = '';
      } else {
        if (key === 'index' && i + 1 === keys.length) {
          route.path += i > 0 ? '' : '/';
        } else {
          route.path += '/' + (key === '_' ? '*' : key.replace('_', ':'));
          if (key !== '_' && key.indexOf('_') !== -1) {
            route.path += '?';
          }
        }
      }
    });
    // Order Routes path
    parent.push(route);
    parent.sort(function (a, b) {
      if (!a.path.length || a.path === '/') {
        return -1;
      }
      if (!b.path.length || b.path === '/') {
        return 1;
      }
      var res = 0;
      var _a = a.path.split('/');
      var _b = b.path.split('/');
      for (var i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break;
        }
        var y = _a[i].indexOf('*') > -1 ? 2 : _a[i].indexOf(':') > -1 ? 1 : 0;
        var z = _b[i].indexOf('*') > -1 ? 2 : _b[i].indexOf(':') > -1 ? 1 : 0;
        res = y - z;
        if (i === _b.length - 1 && res === 0) {
          res = 1;
        }
      }
      return res === 0 ? -1 : res;
    });
  });
  return cleanChildrenRoutes(routes);
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');
var Set = getNative(root, 'Set');
var nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length)
    ? baseUniq(array)
    : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

var index$2 = uniq;

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

var index$7 = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

var index$9 = createCommonjsModule(function (module) {
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
});

var index$13 = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

var ansiRegex = index$13();

var index$11 = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

var re = new RegExp(index$13().source); // remove the `g` flag
var index$15 = re.test.bind(re);

var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

var index$17 = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? index$17 : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	index$9.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(index$9).forEach(function (key) {
		index$9[key].closeRe = new RegExp(index$7(index$9[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk$$1() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = index$9.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		index$9.dim.open = '';
	}

	while (i--) {
		var code = index$9[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	index$9.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

var index$4 = new Chalk();
var styles_1 = index$9;
var hasColor = index$15;
var stripColor = index$11;
var supportsColor_1 = index$17;

index$4.styles = styles_1;
index$4.hasColor = hasColor;
index$4.stripColor = stripColor;
index$4.supportsColor = supportsColor_1;

var index$6 = Object.freeze({
	default: index$4,
	__moduleExports: index$4,
	styles: styles_1,
	hasColor: hasColor,
	stripColor: stripColor,
	supportsColor: supportsColor_1
});

var ref = ( index$6 && index$4 ) || index$6;

function pad (hash$$1, len) {
  while (hash$$1.length < len) {
    hash$$1 = '0' + hash$$1;
  }
  return hash$$1;
}

function fold (hash$$1, text) {
  var i;
  var chr;
  var len;
  if (text.length === 0) {
    return hash$$1;
  }
  for (i = 0, len = text.length; i < len; i++) {
    chr = text.charCodeAt(i);
    hash$$1 = ((hash$$1 << 5) - hash$$1) + chr;
    hash$$1 |= 0;
  }
  return hash$$1 < 0 ? hash$$1 * -2 : hash$$1;
}

function foldObject (hash$$1, o, seen) {
  return Object.keys(o).sort().reduce(foldKey, hash$$1);
  function foldKey (hash$$1, key) {
    return foldValue(hash$$1, o[key], key, seen);
  }
}

function foldValue (input, value, key, seen) {
  var hash$$1 = fold(fold(fold(input, key), toString(value)), typeof value);
  if (value === null) {
    return fold(hash$$1, 'null');
  }
  if (value === undefined) {
    return fold(hash$$1, 'undefined');
  }
  if (typeof value === 'object') {
    if (seen.indexOf(value) !== -1) {
      return fold(hash$$1, '[Circular]' + key);
    }
    seen.push(value);
    return foldObject(hash$$1, value, seen);
  }
  return fold(hash$$1, value.toString());
}

function toString (o) {
  return Object.prototype.toString.call(o);
}

function sum (o) {
  return pad(foldValue(0, o, '', []).toString(16), 8);
}

var hashSum = sum;



var hashSum$2 = Object.freeze({
	default: hashSum,
	__moduleExports: hashSum
});

var hash$1 = ( hashSum$2 && hashSum ) || hashSum$2;

var clientPlugin = createCommonjsModule(function (module, exports) {
'use strict';

/*  */

var isJS = function (file) { return /\.js(\?[^.]+)?$/.test(file); };


var red = ref.red;
var yellow = ref.yellow;

var prefix = "[vue-server-renderer-webpack-plugin]";
var warn = exports.warn = function (msg) { return console.error(red((prefix + " " + msg + "\n"))); };
var tip = exports.tip = function (msg) { return console.log(yellow((prefix + " " + msg + "\n"))); };



var VueSSRClientPlugin = function VueSSRClientPlugin (options) {
  if ( options === void 0 ) options = {};

  this.options = Object.assign({
    filename: 'vue-ssr-client-manifest.json'
  }, options);
};

VueSSRClientPlugin.prototype.apply = function apply (compiler) {
    var this$1 = this;

  compiler.plugin('emit', function (compilation, cb) {
    var stats = compilation.getStats().toJson();

    var allFiles = index$2(stats.assets
      .map(function (a) { return a.name; }));

    var initialFiles = index$2(Object.keys(stats.entrypoints)
      .map(function (name) { return stats.entrypoints[name].assets; })
      .reduce(function (assets, all) { return all.concat(assets); }, [])
      .filter(isJS));

    var asyncFiles = allFiles
      .filter(isJS)
      .filter(function (file) { return initialFiles.indexOf(file) < 0; });

    var manifest = {
      publicPath: stats.publicPath,
      all: allFiles,
      initial: initialFiles,
      async: asyncFiles,
      modules: { /* [identifier: string]: Array<index: number> */ }
    };

    var assetModules = stats.modules.filter(function (m) { return m.assets.length; });
    var fileToIndex = function (file) { return manifest.all.indexOf(file); };
    stats.modules.forEach(function (m) {
      // ignore modules duplicated in multiple chunks
      if (m.chunks.length === 1) {
        var cid = m.chunks[0];
        var chunk = stats.chunks.find(function (c) { return c.id === cid; });
        if (!chunk || !chunk.files) {
          return
        }
        var files = manifest.modules[hash$1(m.identifier)] = chunk.files.map(fileToIndex);
        // find all asset modules associated with the same chunk
        assetModules.forEach(function (m) {
          if (m.chunks.some(function (id) { return id === cid; })) {
            files.push.apply(files, m.assets.map(fileToIndex));
          }
        });
      }
    });

    // const debug = (file, obj) => {
    // require('fs').writeFileSync(__dirname + '/' + file, JSON.stringify(obj, null, 2))
    // }
    // debug('stats.json', stats)
    // debug('client-manifest.json', manifest)

    var json = JSON.stringify(manifest, null, 2);
    compilation.assets[this$1.options.filename] = {
      source: function () { return json; },
      size: function () { return json.length; }
    };
    cb();
  });
};

module.exports = VueSSRClientPlugin;
});

function extractStyles() {
  return !this.options.dev && this.options.build.extractCSS;
}

function styleLoader(ext) {
  var loader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (extractStyles.call(this)) {
    return ExtractTextPlugin.extract({
      use: ['css-loader?minify&sourceMap'].concat(loader),
      fallback: 'vue-style-loader?sourceMap'
    });
  }
  return ['vue-style-loader?sourceMap', 'css-loader?sourceMap'].concat(loader);
}

var vueLoaderConfig = function (_ref) {
  var isClient = _ref.isClient;

  var babelOptions = JSON.stringify(_.defaults(this.options.build.babel, {
    presets: ['vue-app'],
    babelrc: false,
    cacheDirectory: !!this.options.dev
  }));

  // https://github.com/vuejs/vue-loader/blob/master/docs/en/configurations
  var config = {
    postcss: this.options.build.postcss,
    loaders: {
      'js': 'babel-loader?' + babelOptions,
      'css': styleLoader.call(this, 'css'),
      'less': styleLoader.call(this, 'less', 'less-loader'),
      'sass': styleLoader.call(this, 'sass', 'sass-loader?indentedSyntax&?sourceMap'),
      'scss': styleLoader.call(this, 'sass', 'sass-loader?sourceMap'),
      'stylus': styleLoader.call(this, 'stylus', 'stylus-loader'),
      'styl': styleLoader.call(this, 'stylus', 'stylus-loader')
    },
    preserveWhitespace: false,
    extractCSS: extractStyles.call(this)

    // Return the config
  };return config;
};

/*
|--------------------------------------------------------------------------
| Webpack Shared Config
|
| This is the config which is extended by the server and client
| webpack config files
|--------------------------------------------------------------------------
*/
function webpackBaseConfig(_ref) {
  var isClient = _ref.isClient,
      isServer = _ref.isServer;

  var nodeModulesDir = path.join(__dirname, '..', 'node_modules');

  /* istanbul ignore if */
  if (!Array.isArray(this.options.build.postcss)) {
    this.options.build.postcss = [autoprefixer({
      browsers: ['last 3 versions']
    })];
  }

  var config = {
    devtool: this.options.dev ? 'cheap-module-source-map' : 'nosources-source-map',
    entry: {
      vendor: ['vue', 'vue-router', 'vue-meta']
    },
    output: {
      path: path.resolve(this.options.buildDir, 'dist'),
      filename: this.options.build.filenames.app,
      publicPath: isUrl(this.options.build.publicPath) ? this.options.build.publicPath : urlJoin(this.options.router.base, this.options.build.publicPath)
    },
    performance: {
      maxEntrypointSize: 1000000,
      maxAssetSize: 300000,
      hints: this.options.dev ? false : 'warning'
    },
    resolve: {
      extensions: ['.js', '.json', '.vue', '.ts'],
      alias: {
        '~': path.join(this.options.srcDir),
        '~~': path.join(this.options.rootDir),
        '@': path.join(this.options.srcDir),
        '@@': path.join(this.options.rootDir),
        'static': path.join(this.options.srcDir, 'static'), // use in template with <img src="~static/nuxt.png" />
        'assets': path.join(this.options.srcDir, 'assets') // use in template with <img src="~assets/nuxt.png" />
      },
      modules: [path.join(this.options.rootDir, 'node_modules'), nodeModulesDir]
    },
    resolveLoader: {
      modules: [path.join(this.options.rootDir, 'node_modules'), nodeModulesDir]
    },
    module: {
      noParse: /es6-promise\.js$/, // avoid webpack shimming process
      rules: [{
        test: /\.vue$/,
        loader: 'vue-loader',
        query: vueLoaderConfig.call(this, { isClient: isClient, isServer: isServer })
      }, {
        test: /\.js$/,
        loader: 'babel-loader',
        exclude: /node_modules/,
        query: _.defaults(this.options.build.babel, {
          presets: ['vue-app'],
          babelrc: false,
          cacheDirectory: !!this.options.dev
        })
      }, { test: /\.css$/, use: styleLoader.call(this, 'css') }, { test: /\.less$/, use: styleLoader.call(this, 'less', 'less-loader') }, { test: /\.sass$/, use: styleLoader.call(this, 'sass', 'sass-loader?indentedSyntax&sourceMap') }, { test: /\.scss$/, use: styleLoader.call(this, 'sass', 'sass-loader?sourceMap') }, { test: /\.styl(us)?$/, use: styleLoader.call(this, 'stylus', 'stylus-loader') }, {
        test: /\.(png|jpe?g|gif|svg)$/,
        loader: 'url-loader',
        query: {
          limit: 1000, // 1KO
          name: 'img/[name].[hash:7].[ext]'
        }
      }, {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        query: {
          limit: 1000, // 1 KO
          name: 'fonts/[name].[hash:7].[ext]'
        }
      }]
    },
    plugins: this.options.build.plugins

    // CSS extraction
  };if (extractStyles.call(this)) {
    config.plugins.push(new ExtractTextPlugin({ filename: this.options.build.filenames.css }));
  }

  // --------------------------------------
  // Dev specific config
  // --------------------------------------
  if (this.options.dev) {}
  //


  // --------------------------------------
  // Production specific config
  // --------------------------------------
  if (!this.options.dev) {
    // This is needed in webpack 2 for minify CSS
    config.plugins.push(new webpack.LoaderOptionsPlugin({
      minimize: true
    }));

    // Scope Hoisting
    // config.plugins.push(
    //   new webpack.optimize.ModuleConcatenationPlugin()
    // )
  }

  // Clone deep avoid leaking config between Client and Server
  return _.cloneDeep(config);
}

/*
|--------------------------------------------------------------------------
| Webpack Client Config
|
| Generate public/dist/client-vendor-bundle.js
| Generate public/dist/client-bundle.js
|
| In production, will generate public/dist/style.css
|--------------------------------------------------------------------------
*/
function webpackClientConfig() {
  var config = webpackBaseConfig.call(this, { isClient: true });

  config.name = 'client';

  // Entry
  config.entry.app = path.resolve(this.options.buildDir, 'client.js');

  // Add vendors
  if (this.options.store) {
    config.entry.vendor.push('vuex');
  }
  config.entry.vendor = config.entry.vendor.concat(this.options.build.vendor);
  // Extract vendor chunks for better caching
  config.plugins.push(new webpack.optimize.CommonsChunkPlugin({
    name: 'vendor',
    filename: this.options.build.filenames.vendor,
    minChunks: function minChunks(module) {
      // A module is extracted into the vendor chunk when...
      return (
        // If it's inside node_modules
        /node_modules/.test(module.context) &&
        // Do not externalize if the request is a CSS file
        !/\.(css|less|scss|sass|styl|stylus)$/.test(module.request)
      );
    }
  }));

  // Env object defined in nuxt.config.js
  var env = {};
  _.each(this.options.env, function (value, key) {
    env['process.env.' + key] = typeof value === 'string' ? JSON.stringify(value) : value;
  });

  // Webpack common plugins
  /* istanbul ignore if */
  if (!Array.isArray(config.plugins)) {
    config.plugins = [];
  }

  // Generate output HTML
  config.plugins.push(new HTMLPlugin({
    template: this.options.appTemplatePath,
    inject: this.options.render.ssr === false,
    chunksSortMode: 'dependency'
  }));

  // Generate vue-ssr-client-manifest
  config.plugins.push(new clientPlugin({
    filename: 'vue-ssr-client-manifest.json'
  }));

  // Extract webpack runtime & manifest
  config.plugins.push(new webpack.optimize.CommonsChunkPlugin({
    name: 'manifest',
    minChunks: Infinity,
    filename: this.options.build.filenames.manifest
  }));

  // Define Env
  config.plugins.push(new webpack.DefinePlugin(Object.assign(env, {
    'process.env.NODE_ENV': JSON.stringify(env.NODE_ENV || (this.options.dev ? 'development' : 'production')),
    'process.env.VUE_ENV': JSON.stringify('client'),
    'process.browser': true,
    'process.server': false
  })));

  // Build progress bar
  config.plugins.push(new ProgressBarPlugin());

  // --------------------------------------
  // Dev specific config
  // --------------------------------------
  if (this.options.dev) {
    // Add friendly error plugin
    config.plugins.push(new FriendlyErrorsWebpackPlugin());

    // Add HMR support
    config.entry.app = ['webpack-hot-middleware/client?name=$client&reload=true', config.entry.app];
    config.output.filename = '[name].js';
    config.plugins.push(new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin());
  }

  // --------------------------------------
  // Production specific config
  // --------------------------------------
  if (!this.options.dev) {
    // Minify JS
    config.plugins.push(new webpack.optimize.UglifyJsPlugin({
      sourceMap: true,
      compress: {
        warnings: false
      }
    }));

    // Webpack Bundle Analyzer
    if (this.options.build.analyze) {
      config.plugins.push(new webpackBundleAnalyzer.BundleAnalyzerPlugin(Object.assign({}, this.options.build.analyze)));
    }
  }

  // Extend config
  if (typeof this.options.build.extend === 'function') {
    this.options.build.extend.call(this, config, {
      dev: this.options.dev,
      isClient: true
    });
  }

  return config;
}

var serverPlugin = createCommonjsModule(function (module, exports) {
'use strict';

/*  */

var isJS = function (file) { return /\.js(\?[^.]+)?$/.test(file); };


var red = ref.red;
var yellow = ref.yellow;

var prefix = "[vue-server-renderer-webpack-plugin]";
var warn = exports.warn = function (msg) { return console.error(red((prefix + " " + msg + "\n"))); };
var tip = exports.tip = function (msg) { return console.log(yellow((prefix + " " + msg + "\n"))); };

var validate = function (compiler) {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be "node".');
  }

  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be "commonjs2".');
  }

  if (!compiler.options.externals) {
    tip(
      'It is recommended to externalize dependencies in the server build for ' +
      'better build performance.'
    );
  }
};

var VueSSRServerPlugin = function VueSSRServerPlugin (options) {
  if ( options === void 0 ) options = {};

  this.options = Object.assign({
    filename: 'vue-ssr-server-bundle.json'
  }, options);
};

VueSSRServerPlugin.prototype.apply = function apply (compiler) {
    var this$1 = this;

  validate(compiler);

  compiler.plugin('emit', function (compilation, cb) {
    var stats = compilation.getStats().toJson();
    var entryName = Object.keys(stats.entrypoints)[0];
    var entryInfo = stats.entrypoints[entryName];

    if (!entryInfo) {
      // #5553
      return cb()
    }

    var entryAssets = entryInfo.assets.filter(isJS);

    if (entryAssets.length > 1) {
      throw new Error(
        "Server-side bundle should have one single entry file. " +
        "Avoid using CommonsChunkPlugin in the server config."
      )
    }

    var entry = entryAssets[0];
    if (!entry || typeof entry !== 'string') {
      throw new Error(
        ("Entry \"" + entryName + "\" not found. Did you specify the correct entry option?")
      )
    }

    var bundle = {
      entry: entry,
      files: {},
      maps: {}
    };

    stats.assets.forEach(function (asset) {
      if (asset.name.match(/\.js$/)) {
        bundle.files[asset.name] = compilation.assets[asset.name].source();
      } else if (asset.name.match(/\.js\.map$/)) {
        bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
      }
      // do not emit anything else for server
      delete compilation.assets[asset.name];
    });

    var json = JSON.stringify(bundle, null, 2);
    var filename = this$1.options.filename;

    compilation.assets[filename] = {
      source: function () { return json; },
      size: function () { return json.length; }
    };

    cb();
  });
};

module.exports = VueSSRServerPlugin;
});

/*
|--------------------------------------------------------------------------
| Webpack Server Config
|--------------------------------------------------------------------------
*/
function webpackServerConfig() {
  var config = webpackBaseConfig.call(this, { isServer: true });

  config.name = 'server';

  // env object defined in nuxt.config.js
  var env = {};
  _.each(this.options.env, function (value, key) {
    env['process.env.' + key] = typeof value === 'string' ? JSON.stringify(value) : value;
  });

  config = Object.assign(config, {
    target: 'node',
    node: false,
    devtool: 'source-map',
    entry: path.resolve(this.options.buildDir, 'server.js'),
    output: Object.assign({}, config.output, {
      filename: 'server-bundle.js',
      libraryTarget: 'commonjs2'
    }),
    performance: {
      hints: false
    },
    externals: [
    // https://webpack.js.org/configuration/externals/#externals
    // https://github.com/liady/webpack-node-externals
    nodeExternals({
      // load non-javascript files with extensions, presumably via loaders
      whitelist: [/\.(?!(?:js|json)$).{1,5}$/i]
    })],
    plugins: (config.plugins || []).concat([new serverPlugin({
      filename: 'server-bundle.json'
    }), new webpack.DefinePlugin(Object.assign(env, {
      'process.env.NODE_ENV': JSON.stringify(env.NODE_ENV || (this.options.dev ? 'development' : 'production')),
      'process.env.VUE_ENV': JSON.stringify('server'),
      'process.browser': false,
      'process.server': true
    }))])
  });

  // --------------------------------------
  // Production specific config
  // --------------------------------------
  if (!this.options.dev) {}

  // Extend config
  if (typeof this.options.build.extend === 'function') {
    this.options.build.extend.call(this, config, {
      dev: this.options.dev,
      isServer: true
    });
  }

  return config;
}

var debug = Debug('nuxt:build');
debug.color = 2; // Force green color

var glob = pify(Glob);

var Builder = function (_Tapable) {
  inherits(Builder, _Tapable);

  function Builder(nuxt) {
    classCallCheck(this, Builder);

    var _this = possibleConstructorReturn(this, (Builder.__proto__ || Object.getPrototypeOf(Builder)).call(this));

    _this.nuxt = nuxt;
    _this.options = nuxt.options;

    // Fields that set on build
    _this.compiler = null;
    _this.webpackDevMiddleware = null;
    _this.webpackHotMiddleware = null;

    // Mute stats on dev
    _this.webpackStats = _this.options.dev ? false : {
      chunks: false,
      children: false,
      modules: false,
      colors: true

      // Helper to resolve build paths
    };_this.relativeToBuild = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return relativeTo.apply(undefined, [_this.options.buildDir].concat(args));
    };

    // Call builder plugin on parent nuxt to notify all modules of builder existence
    _this.nuxt.applyPluginsAsync('builder', _this).catch(_this.nuxt.errorHandler);

    _this._buildStatus = STATUS.INITIAL;
    return _this;
  }

  createClass(Builder, [{
    key: 'build',
    value: function () {
      var _ref = asyncToGenerator(index$1.mark(function _callee() {
        var _this2 = this;

        var dir;
        return index$1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._buildStatus === STATUS.BUILD_DONE && this.options.dev)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return', this);

              case 2:
                if (!(this._buildStatus === STATUS.BUILDING)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt('return', new Promise(function (resolve$$1) {
                  setTimeout(function () {
                    resolve$$1(_this2.build());
                  }, 1000);
                }));

              case 4:
                this._buildStatus = STATUS.BUILDING;

                // Wait for nuxt ready
                _context.next = 7;
                return this.nuxt.ready();

              case 7:
                _context.next = 9;
                return this.applyPluginsAsync('build', this);

              case 9:

                // Check if pages dir exists and warn if not
                this._nuxtPages = typeof this.options.build.createRoutes !== 'function';

                if (!this._nuxtPages) {
                  _context.next = 18;
                  break;
                }

                if (fs__default.existsSync(path.join(this.options.srcDir, 'pages'))) {
                  _context.next = 18;
                  break;
                }

                dir = this.options.srcDir;

                if (!fs__default.existsSync(path.join(this.options.srcDir, '..', 'pages'))) {
                  _context.next = 17;
                  break;
                }

                throw new Error('No `pages` directory found in ' + dir + '. Did you mean to run `nuxt` in the parent (`../`) directory?');

              case 17:
                throw new Error('Couldn\'t find a `pages` directory in ' + dir + '. Please create one under the project root');

              case 18:

                debug('App root: ' + this.options.srcDir);
                debug('Generating ' + this.options.buildDir + ' files...');

                // Create .nuxt/, .nuxt/components and .nuxt/dist folders
                _context.next = 22;
                return fs.remove(r(this.options.buildDir));

              case 22:
                _context.next = 24;
                return fs.mkdirp(r(this.options.buildDir, 'components'));

              case 24:
                if (this.options.dev) {
                  _context.next = 27;
                  break;
                }

                _context.next = 27;
                return fs.mkdirp(r(this.options.buildDir, 'dist'));

              case 27:
                _context.next = 29;
                return this.generateRoutesAndFiles();

              case 29:
                _context.next = 31;
                return this.webpackBuild();

              case 31:
                _context.next = 33;
                return this.applyPluginsAsync('built', this);

              case 33:

                // Flag to set that building is done
                this._buildStatus = STATUS.BUILD_DONE;

                return _context.abrupt('return', this);

              case 35:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function build() {
        return _ref.apply(this, arguments);
      }

      return build;
    }()
  }, {
    key: 'generateRoutesAndFiles',
    value: function () {
      var _ref2 = asyncToGenerator(index$1.mark(function _callee3() {
        var _this3 = this;

        var templatesFiles, templateVars, layoutsFiles, files, customTemplateFiles;
        return index$1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                debug('Generating files...');
                // -- Templates --
                templatesFiles = ['App.vue', 'client.js', 'index.js', 'middleware.js', 'router.js', 'server.js', 'utils.js', 'components/nuxt-error.vue', 'components/nuxt-loading.vue', 'components/nuxt-child.js', 'components/nuxt-link.js', 'components/nuxt.vue', 'views/app.template.html', 'views/error.html'];
                templateVars = {
                  options: this.options,
                  uniqBy: ___default.uniqBy,
                  isDev: this.options.dev,
                  router: this.options.router,
                  env: this.options.env,
                  head: this.options.head,
                  middleware: fs__default.existsSync(path.join(this.options.srcDir, 'middleware')),
                  store: this.options.store,
                  css: this.options.css,
                  plugins: this.options.plugins.map(function (p, i) {
                    if (typeof p === 'string') p = { src: p };
                    p.src = r(_this3.options.srcDir, p.src);
                    return { src: p.src, ssr: p.ssr !== false, name: 'plugin' + i };
                  }),
                  appPath: './App.vue',
                  layouts: Object.assign({}, this.options.layouts),
                  loading: typeof this.options.loading === 'string' ? this.relativeToBuild(this.options.srcDir, this.options.loading) : this.options.loading,
                  transition: this.options.transition,
                  components: {
                    ErrorPage: this.options.ErrorPage ? this.relativeToBuild(this.options.ErrorPage) : null
                  }

                  // -- Layouts --
                };

                if (!fs__default.existsSync(path.resolve(this.options.srcDir, 'layouts'))) {
                  _context3.next = 9;
                  break;
                }

                _context3.next = 6;
                return glob('layouts/*.vue', { cwd: this.options.srcDir });

              case 6:
                layoutsFiles = _context3.sent;

                layoutsFiles.forEach(function (file) {
                  var name = file.split('/').slice(-1)[0].replace('.vue', '');
                  if (name === 'error') return;
                  templateVars.layouts[name] = _this3.relativeToBuild(_this3.options.srcDir, file);
                });
                if (layoutsFiles.indexOf('layouts/error.vue') !== -1 && !templateVars.components.ErrorPage) {
                  templateVars.components.ErrorPage = this.relativeToBuild(this.options.srcDir, 'layouts/error.vue');
                }

              case 9:
                if (templateVars.layouts.default) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 12;
                return fs.mkdirp(r(this.options.buildDir, 'layouts'));

              case 12:
                templatesFiles.push('layouts/default.vue');
                templateVars.layouts.default = './layouts/default.vue';

              case 14:

                // -- Routes --
                debug('Generating routes...');
                // If user defined a custom method to create routes

                if (!this._nuxtPages) {
                  _context3.next = 22;
                  break;
                }

                _context3.next = 18;
                return glob('pages/**/*.vue', { cwd: this.options.srcDir });

              case 18:
                files = _context3.sent;

                templateVars.router.routes = createRoutes(files, this.options.srcDir);
                _context3.next = 23;
                break;

              case 22:
                templateVars.router.routes = this.options.build.createRoutes(this.options.srcDir);

              case 23:
                _context3.next = 25;
                return this.applyPluginsAsync('extendRoutes', { routes: templateVars.router.routes, templateVars: templateVars, r: r });

              case 25:

                // router.extendRoutes method
                if (typeof this.options.router.extendRoutes === 'function') {
                  // let the user extend the routes
                  this.options.router.extendRoutes(templateVars.router.routes, r);
                }

                // -- Store --
                // Add store if needed
                if (this.options.store) {
                  templatesFiles.push('store.js');
                }

                // Resolve template files
                customTemplateFiles = this.options.build.templates.map(function (t) {
                  return t.dst || path.basename(t.src || t);
                });


                templatesFiles = templatesFiles.map(function (file) {
                  // Skip if custom file was already provided in build.templates[]
                  if (customTemplateFiles.indexOf(file) !== -1) {
                    return;
                  }
                  // Allow override templates using a file with same name in ${srcDir}/app
                  var customPath = r(_this3.options.srcDir, 'app', file);
                  var customFileExists = fs__default.existsSync(customPath);

                  return {
                    src: customFileExists ? customPath : r(_this3.options.nuxtAppDir, file),
                    dst: file,
                    custom: customFileExists
                  };
                }).filter(function (i) {
                  return !!i;
                });

                // -- Custom templates --
                // Add custom template files
                templatesFiles = templatesFiles.concat(this.options.build.templates.map(function (t) {
                  return Object.assign({
                    src: r(_this3.options.srcDir, t.src || t),
                    dst: t.dst || path.basename(t.src || t),
                    custom: true
                  }, t);
                }));

                _context3.next = 32;
                return this.applyPluginsAsync('generate', { builder: this, templatesFiles: templatesFiles, templateVars: templateVars });

              case 32:
                _context3.next = 34;
                return Promise.all(templatesFiles.map(function () {
                  var _ref3 = asyncToGenerator(index$1.mark(function _callee2(_ref4) {
                    var src = _ref4.src,
                        dst = _ref4.dst,
                        options = _ref4.options,
                        custom = _ref4.custom;
                    var fileContent, template, content, path$$1, dateFS;
                    return index$1.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            // Add template to watchers
                            _this3.options.build.watch.push(src);
                            // Render template to dst
                            _context2.next = 3;
                            return fs.readFile(src, 'utf8');

                          case 3:
                            fileContent = _context2.sent;
                            template = ___default.template(fileContent, {
                              imports: {
                                serialize: serialize,
                                hash: hash,
                                r: r,
                                wp: wp,
                                relativeToBuild: _this3.relativeToBuild
                              }
                            });
                            content = template(Object.assign({}, templateVars, {
                              options: options || {},
                              custom: custom,
                              src: src,
                              dst: dst
                            }));
                            path$$1 = r(_this3.options.buildDir, dst);
                            // Ensure parent dir exits

                            _context2.next = 9;
                            return fs.mkdirp(path.dirname(path$$1));

                          case 9:
                            _context2.next = 11;
                            return fs.writeFile(path$$1, content, 'utf8');

                          case 11:
                            // Fix webpack loop (https://github.com/webpack/watchpack/issues/25#issuecomment-287789288)
                            dateFS = Date.now() / 1000 - 1000;
                            return _context2.abrupt('return', fs.utimes(path$$1, dateFS, dateFS));

                          case 13:
                          case 'end':
                            return _context2.stop();
                        }
                      }
                    }, _callee2, _this3);
                  }));

                  return function (_x) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 34:
                _context3.next = 36;
                return this.applyPluginsAsync('generated', this);

              case 36:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function generateRoutesAndFiles() {
        return _ref2.apply(this, arguments);
      }

      return generateRoutesAndFiles;
    }()
  }, {
    key: 'webpackBuild',
    value: function () {
      var _ref5 = asyncToGenerator(index$1.mark(function _callee5() {
        var _this4 = this;

        var compilersOptions, clientConfig, serverConfig, sharedFS, sharedCache;
        return index$1.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                debug('Building files...');
                compilersOptions = [];

                // Client

                clientConfig = webpackClientConfig.call(this);

                compilersOptions.push(clientConfig);

                // Server
                serverConfig = webpackServerConfig.call(this);

                compilersOptions.push(serverConfig);

                // Simulate webpack multi compiler interface
                // Separate compilers are simpler, safer and faster
                this.compiler = { compilers: [] };
                this.compiler.plugin = function () {
                  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                  }

                  _this4.compiler.compilers.forEach(function (compiler) {
                    compiler.plugin.apply(compiler, args);
                  });
                };

                // Initialize shared FS and Cache
                sharedFS = this.options.dev && new MFS();
                sharedCache = {};

                // Initialize compilers

                compilersOptions.forEach(function (compilersOption) {
                  var compiler = webpack(compilersOption);
                  if (sharedFS) {
                    compiler.outputFileSystem = sharedFS;
                  }
                  compiler.cache = sharedCache;
                  _this4.compiler.compilers.push(compiler);
                });

                // Access to compilers with name
                this.compiler.compilers.forEach(function (compiler) {
                  if (compiler.name) {
                    _this4.compiler[compiler.name] = compiler;
                  }
                });

                // Run after each compile
                this.compiler.plugin('done', function () {
                  var _ref6 = asyncToGenerator(index$1.mark(function _callee4(stats) {
                    return index$1.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            if (!(stats.hasErrors() || stats.hasWarnings())) {
                              _context4.next = 2;
                              break;
                            }

                            return _context4.abrupt('return');

                          case 2:
                            // Reload renderer if available
                            if (_this4.nuxt.renderer) {
                              _this4.nuxt.renderer.loadResources(sharedFS || fs__default);
                            }

                            _context4.next = 5;
                            return _this4.applyPluginsAsync('done', { builder: _this4, stats: stats });

                          case 5:
                          case 'end':
                            return _context4.stop();
                        }
                      }
                    }, _callee4, _this4);
                  }));

                  return function (_x2) {
                    return _ref6.apply(this, arguments);
                  };
                }());

                // Add dev Stuff
                if (this.options.dev) {
                  this.webpackDev();
                }

                _context5.next = 16;
                return this.applyPluginsAsync('compile', { builder: this, compiler: this.compiler });

              case 16:
                _context5.next = 18;
                return parallel(this.compiler.compilers, function (compiler) {
                  return new Promise(function (resolve$$1, reject) {
                    if (_this4.options.dev) {
                      // --- Dev Build ---
                      if (compiler.options.name === 'client') {
                        // Client watch is started by dev-middleware
                        resolve$$1();
                      } else {
                        // Build and watch for changes
                        compiler.watch(_this4.options.watchers.webpack, function (err) {
                          /* istanbul ignore if */
                          if (err) {
                            return reject(err);
                          }
                          resolve$$1();
                        });
                      }
                    } else {
                      // --- Production Build ---
                      compiler.run(function (err, stats) {
                        /* istanbul ignore if */
                        if (err) {
                          return reject(err);
                        }
                        if (err) return console.error(err); // eslint-disable-line no-console
                        // Show build stats for production
                        console.log(stats.toString(_this4.webpackStats)); // eslint-disable-line no-console
                        /* istanbul ignore if */
                        if (stats.hasErrors()) {
                          return reject(new Error('Webpack build exited with errors'));
                        }
                        resolve$$1();
                      });
                    }
                  });
                });

              case 18:
                _context5.next = 20;
                return this.applyPluginsAsync('compiled', this);

              case 20:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function webpackBuild() {
        return _ref5.apply(this, arguments);
      }

      return webpackBuild;
    }()
  }, {
    key: 'webpackDev',
    value: function webpackDev() {
      var _this5 = this;

      debug('Adding webpack middleware...');

      // Create webpack dev middleware
      this.webpackDevMiddleware = pify(webpackDevMiddleware(this.compiler.client, {
        publicPath: this.options.build.publicPath,
        stats: this.webpackStats,
        noInfo: true,
        quiet: true,
        watchOptions: this.options.watchers.webpack
      }));

      this.webpackHotMiddleware = pify(webpackHotMiddleware(this.compiler.client, {
        log: false,
        heartbeat: 2500
      }));

      // Inject to renderer instance
      if (this.nuxt.renderer) {
        this.nuxt.renderer.webpackDevMiddleware = this.webpackDevMiddleware;
        this.nuxt.renderer.webpackHotMiddleware = this.webpackHotMiddleware;
      }

      // Stop webpack middleware on nuxt.close()
      this.nuxt.plugin('close', function () {
        return new Promise(function (resolve$$1) {
          _this5.webpackDevMiddleware.close(function () {
            return resolve$$1();
          });
        });
      });

      // Start watching files
      this.watchFiles();
    }
  }, {
    key: 'watchFiles',
    value: function watchFiles() {
      var _this6 = this;

      var patterns = [r(this.options.srcDir, 'layouts'), r(this.options.srcDir, 'store'), r(this.options.srcDir, 'middleware'), r(this.options.srcDir, 'layouts/*.vue'), r(this.options.srcDir, 'layouts/**/*.vue')];
      if (this._nuxtPages) {
        patterns.push(r(this.options.srcDir, 'pages'));
        patterns.push(r(this.options.srcDir, 'pages/*.vue'));
        patterns.push(r(this.options.srcDir, 'pages/**/*.vue'));
      }
      var options = Object.assign({}, this.options.watchers.chokidar, {
        ignoreInitial: true
      });
      /* istanbul ignore next */
      var refreshFiles = ___default.debounce(function () {
        return _this6.generateRoutesAndFiles();
      }, 200);

      // Watch for src Files
      var filesWatcher = chokidar.watch(patterns, options).on('add', refreshFiles).on('unlink', refreshFiles);

      // Watch for custom provided files
      var customFilesWatcher = chokidar.watch(___default.uniq(this.options.build.watch), options).on('change', refreshFiles);

      // Stop watching on nuxt.close()
      this.nuxt.plugin('close', function () {
        filesWatcher.close();
        customFilesWatcher.close();
      });
    }
  }]);
  return Builder;
}(Tapable);

var STATUS = {
  INITIAL: 1,
  BUILD_DONE: 2,
  BUILDING: 3
};

var debug$1 = Debug('nuxt:generate');

var Generator = function (_Tapable) {
  inherits(Generator, _Tapable);

  function Generator(nuxt, builder) {
    classCallCheck(this, Generator);

    var _this = possibleConstructorReturn(this, (Generator.__proto__ || Object.getPrototypeOf(Generator)).call(this));

    _this.nuxt = nuxt;
    _this.options = nuxt.options;
    _this.builder = builder;

    // Set variables
    _this.generateRoutes = path.resolve(_this.options.srcDir, 'static');
    _this.srcBuiltPath = path.resolve(_this.options.buildDir, 'dist');
    _this.distPath = path.resolve(_this.options.rootDir, _this.options.generate.dir);
    _this.distNuxtPath = path.join(_this.distPath, isUrl(_this.options.build.publicPath) ? '' : _this.options.build.publicPath);

    // Call generator plugin on parent nuxt to notify all modules of generator existence
    _this.nuxt.applyPluginsAsync('generator', _this).catch(_this.nuxt.errorHandler);
    return _this;
  }

  createClass(Generator, [{
    key: 'generate',
    value: function () {
      var _ref = asyncToGenerator(index$1.mark(function _callee2() {
        var _this2 = this;

        var doBuild = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var s, errors, generateRoutes, decorateWithPayloads, routes, _loop, nojekyllPath, duration, report;

        return index$1.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                s = Date.now();
                errors = [];
                generateRoutes = [];

                // Wait for nuxt be ready

                _context3.next = 5;
                return this.nuxt.ready();

              case 5:
                if (!(this.builder && doBuild)) {
                  _context3.next = 8;
                  break;
                }

                _context3.next = 8;
                return this.builder.build();

              case 8:
                _context3.next = 10;
                return this.applyPluginsAsync('before-generate', this);

              case 10:
                _context3.next = 12;
                return fs.remove(this.distPath);

              case 12:
                debug$1('Destination folder cleaned');

                // Copy static and built files
                /* istanbul ignore if */

                if (!fs$1.existsSync(this.generateRoutes)) {
                  _context3.next = 16;
                  break;
                }

                _context3.next = 16;
                return fs.copy(this.generateRoutes, this.distPath);

              case 16:
                _context3.next = 18;
                return fs.copy(this.srcBuiltPath, this.distNuxtPath);

              case 18:
                debug$1('Static & build files copied');

                // Resolve config.generate.routes promises before generating the routes

                if (!(this.options.router.mode !== 'hash')) {
                  _context3.next = 34;
                  break;
                }

                _context3.prev = 20;

                console.log('Generating routes'); // eslint-disable-line no-console
                _context3.next = 24;
                return promisifyRoute(this.options.generate.routes || []);

              case 24:
                generateRoutes = _context3.sent;
                _context3.next = 27;
                return this.applyPluginsAsync('generateRoutes', { generator: this, generateRoutes: generateRoutes });

              case 27:
                _context3.next = 34;
                break;

              case 29:
                _context3.prev = 29;
                _context3.t0 = _context3['catch'](20);

                console.error('Could not resolve routes'); // eslint-disable-line no-console
                console.error(_context3.t0); // eslint-disable-line no-console
                throw _context3.t0;

              case 34:
                decorateWithPayloads = function decorateWithPayloads(routes) {
                  var routeMap = {};
                  // Fill routeMap for known routes
                  routes.forEach(function (route) {
                    routeMap[route] = {
                      route: route,
                      payload: null
                    };
                  });
                  // Fill routeMap with given generate.routes
                  generateRoutes.forEach(function (route) {
                    // route is either a string or like {route : "/my_route/1"}
                    var path$$1 = ___default.isString(route) ? route : route.route;
                    routeMap[path$$1] = {
                      route: path$$1,
                      payload: route.payload || null
                    };
                  });
                  return ___default.values(routeMap);
                };

                // Generate only index.html for router.mode = 'hash'


                routes = this.options.router.mode === 'hash' ? ['/'] : flatRoutes(this.options.router.routes);

                routes = decorateWithPayloads(routes);

                _context3.next = 39;
                return this.applyPluginsAsync('generate', { generator: this, routes: routes });

              case 39:
                _loop = index$1.mark(function _loop() {
                  var n;
                  return index$1.wrap(function _loop$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          n = 0;
                          _context2.next = 3;
                          return Promise.all(routes.splice(0, 500).map(function () {
                            var _ref3 = asyncToGenerator(index$1.mark(function _callee(_ref4) {
                              var route = _ref4.route,
                                  payload = _ref4.payload;
                              var html, res, minifyErr, path$$1;
                              return index$1.wrap(function _callee$(_context) {
                                while (1) {
                                  switch (_context.prev = _context.next) {
                                    case 0:
                                      _context.next = 2;
                                      return waitFor(n++ * _this2.options.generate.interval);

                                    case 2:
                                      html = void 0;
                                      _context.prev = 3;
                                      _context.next = 6;
                                      return _this2.nuxt.renderer.renderRoute(route, { _generate: true, payload: payload });

                                    case 6:
                                      res = _context.sent;

                                      html = res.html;
                                      if (res.error) {
                                        errors.push({ type: 'handled', route: route, error: res.error });
                                      }
                                      _context.next = 14;
                                      break;

                                    case 11:
                                      _context.prev = 11;
                                      _context.t0 = _context['catch'](3);
                                      return _context.abrupt('return', errors.push({ type: 'unhandled', route: route, error: _context.t0 }));

                                    case 14:
                                      if (_this2.options.generate.minify) {
                                        try {
                                          html = htmlMinifier.minify(html, _this2.options.generate.minify);
                                        } catch (err) /* istanbul ignore next */{
                                          minifyErr = new Error('HTML minification failed. Make sure the route generates valid HTML. Failed HTML:\n ' + html);

                                          errors.push({ type: 'unhandled', route: route, error: minifyErr });
                                        }
                                      }
                                      path$$1 = path.join(route, path.sep, 'index.html'); // /about -> /about/index.html

                                      path$$1 = path$$1 === '/404/index.html' ? '/404.html' : path$$1; // /404 -> /404.html
                                      debug$1('Generate file: ' + path$$1);
                                      path$$1 = path.join(_this2.distPath, path$$1);
                                      // Make sure the sub folders are created
                                      _context.next = 21;
                                      return fs.mkdirp(path.dirname(path$$1));

                                    case 21:
                                      _context.next = 23;
                                      return fs.writeFile(path$$1, html, 'utf8');

                                    case 23:
                                    case 'end':
                                      return _context.stop();
                                  }
                                }
                              }, _callee, _this2, [[3, 11]]);
                            }));

                            return function (_x2) {
                              return _ref3.apply(this, arguments);
                            };
                          }()));

                        case 3:
                        case 'end':
                          return _context2.stop();
                      }
                    }
                  }, _loop, _this2);
                });

              case 40:
                if (!routes.length) {
                  _context3.next = 44;
                  break;
                }

                return _context3.delegateYield(_loop(), 't1', 42);

              case 42:
                _context3.next = 40;
                break;

              case 44:

                // Add .nojekyll file to let Github Pages add the _nuxt/ folder
                // https://help.github.com/articles/files-that-start-with-an-underscore-are-missing/
                nojekyllPath = path.resolve(this.distPath, '.nojekyll');

                fs.writeFile(nojekyllPath, '');
                duration = Math.round((Date.now() - s) / 100) / 10;

                debug$1('HTML Files generated in ' + duration + 's');

                if (errors.length) {
                  report = errors.map(function (_ref2) {
                    var type = _ref2.type,
                        route = _ref2.route,
                        error = _ref2.error;

                    /* istanbul ignore if */
                    if (type === 'unhandled') {
                      return 'Route: \'' + route + '\'\n' + error.stack;
                    } else {
                      return 'Route: \'' + route + '\' thrown an error: \n' + JSON.stringify(error);
                    }
                  });

                  console.error('==== Error report ==== \n' + report.join('\n\n')); // eslint-disable-line no-console
                }

                _context3.next = 51;
                return this.applyPluginsAsync('generated', this);

              case 51:
                return _context3.abrupt('return', { duration: duration, errors: errors });

              case 52:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee2, this, [[20, 29]]);
      }));

      function generate() {
        return _ref.apply(this, arguments);
      }

      return generate;
    }()
  }]);
  return Generator;
}(Tapable);

var index = {
  Builder: Builder,
  Generator: Generator
};

module.exports = index;
//# sourceMappingURL=builder.js.map
